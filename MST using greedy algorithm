#include <stdio.h>
#include <stdlib.h>

#define MAX 30

typedef struct {
    int u, v, w;
} Edge;

typedef struct {
    int parent[MAX];
    int rank[MAX];
} DisjointSet;

void makeSet(DisjointSet *ds, int n) {
    for (int i = 0; i < n; i++) {
        ds->parent[i] = i;
        ds->rank[i] = 0;
    }
}

int find(DisjointSet *ds, int i) {
    if (ds->parent[i] != i)
        ds->parent[i] = find(ds, ds->parent[i]);
    return ds->parent[i];
}

void unionSets(DisjointSet *ds, int u, int v) {
    int rootU = find(ds, u);
    int rootV = find(ds, v);

    if (rootU != rootV) {
        if (ds->rank[rootU] > ds->rank[rootV])
            ds->parent[rootV] = rootU;
        else if (ds->rank[rootU] < ds->rank[rootV])
            ds->parent[rootU] = rootV;
        else {
            ds->parent[rootV] = rootU;
            ds->rank[rootU]++;
        }
    }
}

int compare(const void *a, const void *b) {
    Edge *edgeA = (Edge *)a;
    Edge *edgeB = (Edge *)b;
    return edgeA->w - edgeB->w;
}

void kruskalMST(Edge edges[], int n, int e) {
    DisjointSet ds;
    makeSet(&ds, n);

    qsort(edges, e, sizeof(Edge), compare);
    printf("G.SHYAMALA 192211641");
    printf("Edges in the MST:\n");
    for (int i = 0; i < e; i++) {
        int u = edges[i].u;
        int v = edges[i].v;
        int setU = find(&ds, u);
        int setV = find(&ds, v);

        if (setU != setV) {
            printf("%d - %d: %d\n", u, v, edges[i].w);
            unionSets(&ds, setU, setV);
        }
    }
}

int main() {
    int n = 4; 
    int e = 5; 
    Edge edges[] = {
        {0, 1, 10},
        {0, 2, 6},
        {0, 3, 5},
        {1, 3, 15},
        {2, 3, 4}
    };

    kruskalMST(edges, n, e);

    return 0;
}
